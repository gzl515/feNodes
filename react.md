## React基础
### React 哲学
1. 将 UI 拆解为组件层级结构 
2. 使用 React 构建一个静态版本 
3. 找出 UI 精简且完整的 state 表示 
    - 随着时间推移 保持不变？如此，便不是 state。
    - 通过 props 从父组件传递？如此，便不是 state。
    - 是否可以基于已存在于组件中的 state 或者 props 进行计算？如此，它肯定不是state！
4. 验证 state 应该被放置在哪里 
5. 添加反向数据流 

### 为什么一定要纯函数
- 你的组件可以在不同的环境下运行，例如，在服务器上！由于它们针对相同的输入，总是返回相同的结果，因此一个组件可以满足多个用户请求。
- 你可以为那些输入未更改的组件来 跳过渲染，以提高性能。这是安全的做法，因为纯函数总是返回相同的结果，所以可以安全地缓存它们。
- 如果在渲染深层组件树的过程中，某些数据发生了变化，React 可以重新开始渲染，而不会浪费时间完成过时的渲染。纯粹性使得它随时可以安全地停止计算。

### 构建 state 的原则 
1. 合并关联的 state。如果你总是同时更新两个或更多的 state 变量，请考虑将它们合并为一个单独的 state 变量。
2. 避免互相矛盾的 state。当 state 结构中存在多个相互矛盾或“不一致”的 state 时，你就可能为此会留下隐患。应尽量避免这种情况。
3. 避免冗余的 state。如果你能在渲染期间从组件的 props 或其现有的 state 变量中计算出一些信息，则不应将这些信息放入该组件的 state 中。
4. 避免重复的 state。当同一数据在多个 state 变量之间或在多个嵌套对象中重复时，这会很难保持它们同步。应尽可能减少重复。
5. 避免深度嵌套的 state。深度分层的 state 更新起来不是很方便。如果可能的话，最好以扁平化方式构建 state。

### 对比 useState 和 useReducer 
- 代码体积
- 可读性
- 可调试性
- 可测试性
- 个人偏好
#### 编写一个好的 reducers
- reducers 必须是纯粹的
- 每个 action 都描述了一个单一的用户交互，即使它会引发数据的多个变化

### 写在你使用 context 之前 
如果你只想把一些 props 传递到多个层级中，这并不意味着你需要把这些信息放到 context 里。
在使用 context 之前，你可以考虑以下几种替代方案：
1. 从 传递 props 开始。
2. 抽象组件并 将 JSX 作为 children 传递 给它们。
#### Context 的使用场景 
- 主题
- 当前账户
- 路由
- 状态管理

## React 内置 Hook
### State Hook
状态帮助组件 “记住”用户输入的信息。例如，一个表单组件可以使用状态存储输入值，而一个图像库组件可以使用状态存储所选的图像索引。
- 使用 useState 声明可以直接更新的状态变量。
- 使用 useReducer 在 reducer 函数中声明带有更新逻辑的 state 变量。
### Context Hook
上下文帮助组件 从祖先组件接收信息，而无需将其作为 props 传递。例如，应用程序的顶层组件可以借助上下文将 UI 主题传递给所有下方的组件，无论这些组件层级有多深。
- 使用 useContext 读取订阅上下文。
### Ref Hook
ref 允许组件 保存一些不用于渲染的信息，比如 DOM 节点或 timeout ID。与状态不同，更新 ref 不会重新渲染组件。ref 是从 React 范例中的“脱围机制”。当需要与非 React 系统如浏览器内置 API 一同工作时，ref 将会非常有用。
- 使用 useRef 声明 ref。你可以在其中保存任何值，但最常用于保存 DOM 节点。
- 使用 useImperativeHandle 自定义从组件中暴露的 ref，但是很少使用。
### Effect Hook 
Effect 允许组件 连接到外部系统并与之同步。这包括处理网络、浏览器、DOM、动画、使用不同 UI 库编写的小部件以及其他非 React 代码。
- 使用 useEffect 将组件连接到外部系统。
- useLayoutEffect 在浏览器重新绘制屏幕前执行，可以在此处测量布局。
- useInsertionEffect 在 React 对 DOM 进行更改之前触发，库可以在此处插入动态 CSS。
### 性能 Hook
优化重新渲染性能的一种常见方法是跳过不必要的工作。例如，可以告诉 React 重用缓存的计算结果，或者如果数据自上次渲染以来没有更改，则跳过重新渲染。
可以使用以下 Hook 跳过计算和不必要的重新渲染：
- 使用 useMemo 缓存计算代价昂贵的计算结果。
- 使用 useCallback 将函数传递给优化组件之前缓存函数定义。

有时由于屏幕确实需要更新，无法跳过重新渲染。在这种情况下，可以通过将必须同步的阻塞更新（比如使用输入法输入内容）与不需要阻塞用户界面的非阻塞更新（比如更新图表）分离以提高性能。
使用以下 Hook 处理渲染优先级：
- useTransition 允许将状态转换标记为非阻塞，并允许其他更新中断它。
- useDeferredValue 允许延迟更新 UI 的非关键部分，以让其他部分先更新。
### 资源 Hook 
资源可以被组件访问，而无需将它们作为状态的一部分。例如，组件可以从 Promise 中读取消息，或从上下文中读取样式信息。
- use 允许读取像 Promise 或 上下文 这样的资源的值。
### 其他 Hook 
这些 Hook 主要适用于库作者，不常在应用程序代码中使用。
- 使用 useDebugValue 自定义 React 开发者工具为自定义 Hook 添加的标签。
- 使用 useId 将唯一的 ID 与组件相关联，其通常与可访问性 API 一起使用。
- 使用 useSyncExternalStore 订阅外部 store。
### 自定义 Hook
[自定义hook](https://react.docschina.org/learn/reusing-logic-with-custom-hooks#extracting-your-own-custom-hook-from-a-component)

## 内置组件
- `<Fragment>`，也可以写作 <>...</>，让你可以将多个 JSX 节点组合在一起。
- `<Profiler>` 让你可以以编程方式衡量 React 树的渲染性能。
- `<Suspense>` 让你可以在子组件加载时显示后备方案。
- `<StrictMode>` 可以开启一些额外的，仅用于开发环境的检测，帮助你更早地发现 bug。
